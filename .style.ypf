[стиль]
# Совместите закрывающую скобку с визуальным отступом.
align_closing_bracket_with_visual_indent = True

# Разрешить ключи словаря существовать на нескольких строках. Например:
#
# x = {
# ('это первый элемент кортежа',
# 'это второй элемент кортежа'):
# значение,
#}
allow_multiline_dictionary_keys = False

# Разрешить форматирование лямбды более чем на одной строке.
allow_multiline_lambdas = False

# Разрешить разбиение перед значением словаря.
allow_split_before_dict_value = True

# Количество пустых строк, окружающих функцию и класс верхнего уровня
# определения.
blank_lines_around_top_level_definition = 2

# Вставить пустую строку перед строкой документации на уровне класса.
blank_line_before_class_docstring = False

# Вставить пустую строку перед строкой документа.
blank_line_before_module_docstring = False

# Вставить пустую строку перед непосредственным вложением 'def' или 'class'
# внутри другого 'def' или 'class'. Например:
#
# класс Foo:
# # <------ эта пустая строка
# def method ():
# ...
blank_line_before_nested_class_or_def = False

# Не разделяйте последовательные скобки. Актуально только когда
# dedent_closing_brackets установлен. Например:
#
# call_func_that_takes_a_dict (
# {
# 'key1': 'value1',
# 'key2': 'value2',
#}
#)
#
# переформатировал бы в:
#
# call_func_that_takes_a_dict ({
# 'key1': 'value1',
# 'key2': 'value2',
#})
coalesce_brackets = False

# Лимит столбца.
column_limit = 160

# Стиль для продолжения выравнивания. Возможные значения:
#
# - ПРОБЕЛ: Используйте пробелы для продолжения выравнивания. Это поведение по умолчанию.
# - ИСПРАВЛЕНО: использовать фиксированное число (CONTINUATION_INDENT_WIDTH) столбцов
# (т.е. вкладки CONTINUATION_INDENT_WIDTH / INDENT_WIDTH) для продолжения
# выравнивание.
# - МЕНЬШЕ: немного влево, если не удается выровнять линии продолжения вертикально
# отступ символов.
# - VALIGN-RIGHT: вертикально выровнять линии продолжения с отступом
# персонажи. Немного прав (еще один отступ), если не можете
# вертикально выравнивать строки продолжения с отступом символов.
#
# Для опций FIXED и VALIGN-RIGHT доступны только когда USE_TABS
# включен.
continuation_align_style = ПРОСТРАНСТВО

# Ширина отступа, используемая для продолжения строки.
continuation_indent_width = 4

# Поместите закрывающие скобки в отдельной строке, с отступом, если в скобках
# выражение не может поместиться в одну строку. Относится ко всем видам скобок,
# включая определения функций и вызовов. Например:
#
# config = {
# 'key1': 'value1',
# 'key2': 'value2',
#} # <--- эта скобка выделена и находится на отдельной строке
#
# time_series = self.remote_client.query_entity_counters (
# entity = 'dev3246.region1',
# key = 'dns.query_latency_tcp',
# transform = Transformation.AVERAGE (window = timedelta (секунд = 60)),
# start_ts = now () - timedelta (days = 3),
# end_ts = now (),
#) # <--- эта скобка выделена и находится на отдельной строке
dedent_closing_brackets = False

# Отключить эвристику, которая помещает каждый элемент списка в отдельную строку
# если список оканчивается запятыми.
disable_ending_comma_heuristic = False

# Поместите каждую словарную статью в отдельную строку.
each_dict_entry_on_separate_line = True

# Регулярное выражение для комментария i18n. Наличие этого комментария прекращается
# переформатирование этой строки, потому что комментарии должны быть
# рядом со строкой, которую они переводят.
i18n_comment =

# Имена вызовов функций i18n. Наличие этой функции прекращается
# переформатировать в этой строке, потому что строка, которую она имеет, не может быть перемещена
# от комментария i18n.
i18n_function_call =

# Отступить значение словаря, если оно не может поместиться в той же строке, что и
# словарный ключ. Например:
#
# config = {
# 'key1':
# 'value1',
# 'key2': value1 +
# значение2,
#}
indent_dictionary_value = False

# Количество столбцов, используемых для отступа.
indent_width = 4

# Соединяйте короткие строки в одну строку. Например, операторы if, состоящие из одной строки.
join_multiple_lines = True

# Не включайте пробелы вокруг выбранных бинарных операторов. Например:
#
# 1 + 2 * 3 - 4/5
#
# будет отформатирован следующим образом при настройке "*, /":
#
# 1 + 2 * 3 - 4/5
#
no_spaces_around_selected_binary_operators =

# Используйте пробелы вокруг имен по умолчанию или именованных.
spaces_around_default_or_named_assign = False

# Используйте пробелы вокруг оператора питания.
spaces_around_power_operator = False

# Количество пробелов, необходимых перед завершающим комментарием.
spaces_before_comment = 2

# Вставить пробел между конечной запятой и закрывающей скобкой списка,
# и т.д.
space_between_ending_comma_and_closing_bracket = True

# Разделить перед аргументами
split_all_comma_separated_values ​​= False

# Разделить перед аргументами, если список аргументов завершается
# запятая.
split_arguments_when_comma_terminated = False

# Установите True, чтобы предпочитать разделение перед '&', '|' или «^», а не
# после.
split_before_bitwise_operator = True

# Разделить перед закрывающей скобкой, если список или литерал dict не помещается на
# одна строка.
split_before_closing_bracket = True

# Разделить перед словарем или установить генератор (comp_for). Например, обратите внимание
# раскол перед 'для':
#
# foo = {
# variable: 'Hello world, хорошего дня!'
# для переменной в баре, если переменная! = 42
#}
split_before_dict_set_generator = True

# Разделить перед «.» если нам нужно разделить более длинное выражение:
#
# foo = ('Это действительно длинная строка: {}, {}, {}, {}'. format (a, b, c, d))
#
# переформатировал бы что-то вроде:
#
# foo = ('Это действительно длинная строка: {}, {}, {}, {}'
# .формат (a, b, c, d))
split_before_dot = False

# Разделить после открытия парен, который окружает выражение, если это не так
# помещается на одной строке.
split_before_expression_after_opening_paren = False

# Если список аргументов / параметров будет разделен, то перед
# первый аргумент.
split_before_first_argument = False

# Установите True, чтобы предпочитать расщепление перед 'и' или 'или', а не
# после.
split_before_logical_operator = True

# Разделить именованные назначения на отдельные строки.
split_before_named_assigns = True

# Установите значение True, чтобы разделить список представлений и генераторов, которые имеют
# нетривиальные выражения и несколько предложений перед каждым из них
# пункты. Например:
#
# результат = [
# a_long_var + 100 для a_long_var в xrange (1000)
# if a_long_var% 10]
#
# переформатировал бы что-то вроде:
#
# результат = [
# a_long_var + 100
# для a_long_var в xrange (1000)
# if a_long_var% 10]
split_complex_comprehension = False

# Штраф за расщепление сразу после открывающей скобки.
split_penalty_after_opening_bracket = 30

# Штраф за разбиение строки после унарного оператора.
split_penalty_after_unary_operator = 10000

# Наказание за разбиение прямо перед выражением if.
split_penalty_before_if_expr = 0

# Наказание за разбиение строки вокруг '&', '|' и '^'
# операторы.
split_penalty_bitwise_operator = 300

# Наказание за разбиение списка понимания или генератора
# выражение.
split_penalty_comprehension = 80

# Штраф за символы сверх лимита столбца.
split_penalty_excess_character = 7000

# Штраф, возникающий при добавлении строки, разделенной на развернутую строку. 
Чем больше добавлено разделений строк, тем выше штраф.
split_penalty_for_added_line_split = 30

# Наказание за разбиение списка имен «импортировать как». Например:
#
# из импорта a_very_long_or_indented_module_name_yada_yad (long_argument_1,
# long_argument_2,
# long_argument_3)
#
# переформатировал бы что-то вроде:
#
# из импорта a_very_long_or_indented_module_name_yada_yad (
# long_argument_1, long_argument_2, long_argument_3)
split_penalty_import_names = 0

# Наказание за разбиение строки вокруг 'и' и 'или'
# операторы.
split_penalty_logical_operator = 300

# Используйте символ табуляции для отступа.
use_tabs = False
